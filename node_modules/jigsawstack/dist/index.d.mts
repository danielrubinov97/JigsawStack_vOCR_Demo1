interface BaseResponse {
    success: boolean;
}

interface FileUploadParams {
    overwrite?: boolean;
    filename: string;
}
interface FileUploadResponse extends BaseResponse {
    key: string;
    url: string;
}

interface SearchParams {
    query: string;
    ai_overview?: boolean;
    safe_search?: "moderate" | "strict" | "off";
    spell_check?: boolean;
}
interface RelatedIndex {
    title: string;
    url: string;
    description: string;
    is_safe?: boolean;
}
interface SearchResponse {
    success: boolean;
    query: string;
    spell_fixed: string;
    is_safe: boolean;
    ai_overview: string;
    results: {
        title: string;
        url: string;
        description: string;
        content: string;
        is_safe: boolean;
        site_name: string;
        site_long_name: string;
        age: string;
        language: string;
        favicon: string;
        snippets: string[];
        related_index: RelatedIndex[];
    }[];
}
interface SuggestionResponse {
    success: boolean;
    suggestions: string[];
}

interface HTMLAnyParams {
    html?: string;
    url?: string;
    use_graphic_renderer?: boolean;
    dark_mode?: boolean;
    is_mobile?: boolean;
    pdf_page_range?: string;
    pdf_print_background?: boolean;
    pdf_display_header_footer?: boolean;
    size_preset?: string;
    height?: number;
    width?: number;
    type?: string;
    quality?: number;
    omit_background?: boolean;
    full_page?: boolean;
    scale?: number;
    goto_options?: {
        timeout: number;
        wait_until: string;
    };
}

interface DNSParams {
    domain: string;
    type: string;
}
interface DNSRecord {
    name: string;
    type: number;
    TTL: number;
    data: string;
}
interface DNSResponse {
    success: boolean;
    status: number;
    domain: string;
    type: string;
    type_value: number;
    records: DNSRecord[];
    authority: any[];
    additional: any[];
    truncated: boolean;
    recursion_desired: boolean;
    recursion_available: boolean;
    DNSSEC_verified: boolean;
    DNSSEC_validation_disabled: boolean;
}

interface CookieParameter {
    name: string;
    value: string;
    url?: string;
    domain?: string;
    path?: string;
    secure?: boolean;
    httpOnly?: boolean;
    sameSite?: "Strict" | "Lax" | "None";
    expires?: boolean;
    priority?: string;
    sameParty?: boolean;
}
interface ScrapeParams {
    url: string;
    elements?: Array<{
        selector: string;
    }>;
    http_headers?: object;
    reject_request_pattern?: string[];
    goto_options?: {
        timeout: number;
        wait_until: string;
    };
    wait_for?: {
        mode: string;
        value: string | number;
    };
    advance_config?: {
        console: boolean;
        network: boolean;
        cookies: boolean;
    };
    size_preset?: string;
    is_mobile?: boolean;
    scale?: number;
    width?: number;
    height?: number;
    cookies?: Array<CookieParameter>;
}
interface ScrapeResponse {
    success: boolean;
    data: any;
}
interface AIScrapeParams extends Omit<ScrapeParams, "elements"> {
    element_prompts: string[];
}

interface SentimentResponse extends BaseResponse {
    sentiment: {
        emotion: "happiness";
        sentiment: "positive";
        score: 0.9;
    };
}
interface TranslateResponse extends BaseResponse {
    translated_text: string;
}
interface TextToSQLResponse extends BaseResponse {
    sql: string;
}
interface SummaryResponse extends BaseResponse {
    summary: string;
}
interface PredictionParams {
    dataset: Array<{
        value: number | string;
        date: string;
    }>;
    steps: number;
}
interface PredictionResponse extends BaseResponse {
    prediction: PredictionParams["dataset"];
}

declare class RequestClient {
    private readonly config;
    constructor(config: {
        apiKey: string;
        baseURL?: string;
    });
    readonly fetchJSS: (path: string, method: "POST" | "GET" | "DELETE", body?: Record<string, any> | Blob, searchParams?: {
        [key: string]: any;
    }, headers?: {
        [key: string]: string;
    }) => Promise<any>;
}

interface SpeechToTextParams {
    url?: string;
    file_store_key?: string;
    language?: string;
    translate?: boolean;
    by_speaker?: boolean;
    webhook_url?: string;
}
interface SpeechToTextResponse extends BaseResponse {
    text: string;
    chunks: Array<{
        timestamp: number[];
        text: string;
    }>;
    status?: "processing" | "error";
    id?: string;
}
interface TextToSpeechParams {
    text: string;
    accent?: string;
    speaker_clone_url?: string;
    speaker_clone_file_store_key?: string;
}

declare class Audio {
    private readonly client;
    constructor(client: RequestClient);
    speech_to_text: (params: SpeechToTextParams) => Promise<SpeechToTextResponse>;
    text_to_speech: (params: TextToSpeechParams) => Promise<{
        blob: () => Promise<Blob>;
        buffer: () => Promise<Buffer>;
        file: (filename: string) => Promise<File>;
    }>;
}

interface GeoParams {
    search_value: string;
    lat: string;
    lng: string;
    country_code: string;
    proximity_lat: string;
    proximity_lng: string;
    types: string;
    city_code: string;
    state_code: string;
    limit: number;
}
interface GeoSearchParams {
    search_value: string;
    country_code?: string;
    proximity_lat?: string;
    proximity_lng?: string;
    types?: string;
}
interface Geoloc {
    type: string;
    coordinates: number[];
}
interface Region {
    name: string;
    region_code: string;
    region_code_full: string;
}
interface Country {
    name: string;
    country_code: string;
    country_code_alpha_3: string;
}
interface GeoSearchResult {
    type: string;
    full_address: string;
    name: string;
    place_formatted: string;
    postcode: string;
    place: string;
    region: Region;
    country: Country;
    language: string;
    geoloc: Geoloc;
    poi_category: string[];
    addtional_properties: Record<string, any>;
}
interface CityResult {
    state_code: string;
    name: string;
    city_code: string;
    state: StateResult;
}
interface CountryResult {
    country_code: string;
    name: string;
    iso2: string;
    iso3: string;
    capital: string;
    phone_code: string;
    region: string;
    subregion: string;
    currency_code: string;
    geoloc: Geoloc;
    currency_name: string;
    currency_symbol: string;
    tld: string;
    native: string;
    emoji: string;
    emojiU: string;
    latitude: number;
    longitude: number;
}
interface StateResult {
    state_code: string;
    name: string;
    country_code: string;
    country: CountryResult;
}
interface GeoSearchResponse extends BaseResponse {
    data: GeoSearchResult[];
}
interface GeocodeParams extends Omit<GeoParams, "state_code" | "city_code"> {
}
interface GeoCityParams extends Pick<GeoParams, "country_code" | "city_code" | "state_code" | "search_value" | "lat" | "lng" | "limit"> {
}
interface GeoCityResponse extends BaseResponse {
    city: CityResult[];
}
interface GeoCountryParams extends Pick<GeoParams, "country_code" | "city_code" | "search_value" | "lat" | "lng" | "limit"> {
    currency_code: string;
}
interface GeoCountryResponse extends BaseResponse {
    country: CountryResult[];
}
interface GeoStateParams extends Pick<GeoParams, "country_code" | "state_code" | "search_value" | "lat" | "lng" | "limit"> {
}
interface GeoStateResponse extends BaseResponse {
    state: StateResult[];
}
interface GeoDistanceParams {
    unit?: "K" | "N";
    lat1: string;
    lng1: string;
    lat2: string;
    lng2: string;
}
interface GeoDistanceResponse extends BaseResponse {
    distance: number;
}
interface GeoTimezoneParams extends Pick<GeoParams, "lat" | "lng" | "city_code" | "country_code"> {
}
interface GeoTimezoneResponse extends BaseResponse {
    timezone: {
        abbr: string;
        name: string;
        offset: number;
        zone_name: string;
        gmt_offset: number;
        gmt_offset_name: string;
    };
}
interface GeohashParams extends Pick<GeoParams, "lat" | "lng"> {
    precision: number;
}
interface GeohashResponse extends BaseResponse {
    geohash: string;
}
interface GeohashDecodeResponse extends BaseResponse {
    latitude: number;
    longitude: number;
}

declare class Geo {
    private readonly client;
    constructor(client: RequestClient);
    search: (params: GeoSearchParams) => Promise<GeoSearchResponse>;
    geocode: (params: GeocodeParams) => Promise<GeoSearchResponse>;
    city: (params: GeoCityParams) => Promise<GeoCityResponse>;
    country: (params: GeoCountryParams) => Promise<GeoCountryResponse>;
    state: (params: GeoStateParams) => Promise<GeoStateResponse>;
    distance: (params: GeoDistanceParams) => Promise<GeoDistanceResponse>;
    timezone: (params: GeoTimezoneParams) => Promise<GeoTimezoneResponse>;
    geohash: (params: GeohashParams) => Promise<GeohashResponse>;
    geohash_decode: (geohash: string) => Promise<GeohashDecodeResponse>;
}

interface VOCRParams {
    prompt: string | string[];
    url?: string;
    file_store_key?: string;
}
interface VOCRResponse {
    success: boolean;
    context: string;
    width: number;
    height: number;
    tags: string[];
    has_text: boolean;
    sections: Array<any>;
}
interface ObjectDetentionParams {
    url?: string;
    file_store_key?: string;
}
interface ObjectDetectionResponse extends Omit<VOCRResponse, "context"> {
    success: boolean;
    width: number;
    height: number;
    tags: string[];
    has_text: boolean;
    sections: Array<any>;
}

declare class Vision {
    private readonly client;
    constructor(client: RequestClient);
    vocr: (params: VOCRParams) => Promise<VOCRResponse>;
    object_detection: (params: ObjectDetentionParams) => Promise<ObjectDetectionResponse>;
}

interface PromptCreateParams {
    prompt: string;
    return_prompt?: string | Array<Record<string, any>> | Record<string, any>;
    inputs?: Array<{
        key: string;
        optional?: boolean;
        initial_value?: string;
    }>;
}
interface PromptRunParams extends PromptCreateParams {
    input_values?: Record<string, any>;
}
interface PromptExecuteParams {
    id: string;
    input_values?: Record<string, any>;
}
interface PromptListParams {
    page?: number;
    limit?: number;
}
interface PromptResult {
    id: string;
    prompt: string;
    inputs: Array<{
        key: string;
        optional: boolean;
    }>;
    return_prompt: string;
    created_at: string;
}
interface PromptGetResponse extends PromptResult {
    success: boolean;
}
interface PromptListResponse extends PromptResult {
    prompt_engines: PromptResult[];
}

declare class PromptEngine {
    private readonly client;
    constructor(client: RequestClient);
    create: (params: PromptCreateParams) => Promise<{
        prompt_engine_id: string;
    }>;
    run_prompt_direct: <T>(params: PromptRunParams) => Promise<{
        result: T;
        success: boolean;
        message?: string;
    }>;
    get: (id: string) => Promise<PromptGetResponse>;
    list: (params?: PromptListParams) => Promise<PromptListResponse>;
    delete: (id: string) => Promise<{
        prompt_engine_id: string;
    }>;
    run: <T>(params: PromptExecuteParams) => Promise<{
        result: T;
        success: boolean;
    }>;
}

interface KVAddParams {
    encrypt?: boolean;
    value: string;
    key: string;
}
interface KVAddResponse extends BaseResponse {
    url: string;
    key: string;
}

declare class KV {
    private readonly client;
    constructor(client: RequestClient);
    add: (params: KVAddParams) => Promise<KVAddResponse>;
    get: (key: string) => Promise<BaseResponse & {
        value: string;
    }>;
    delete: (key: string) => Promise<BaseResponse>;
}

interface EmailValidationResponse {
    email: string;
    disposable: boolean;
    role_account: boolean;
    free: boolean;
    has_mx_records: boolean;
    username: string;
    domain: string;
    valid: boolean;
}
interface NSFWValidationResponse {
    success: boolean;
}
interface ProfanityParams {
    text: string;
    censor_replacement?: string;
}
interface ProfanityValidationResponse {
    success: boolean;
    message: string;
    clean_text: string;
    profanities: string[];
    profanities_found: number;
}
interface SpellCheckParams {
    text: string;
    language_code?: string;
}
interface SpellCheckValidationResponse {
    success: boolean;
    message: string;
    misspellings_found: number;
    auto_correct_text: string;
}
interface SpamCheckValidationResponse {
    success: boolean;
    check: {
        is_spam: boolean;
        score: number;
    };
}

declare class Validate {
    private readonly client;
    constructor(client: RequestClient);
    email: (email: string) => Promise<EmailValidationResponse>;
    nsfw: (url: string) => Promise<NSFWValidationResponse>;
    profanity: ({ text, censor_replacement }: ProfanityParams) => Promise<ProfanityValidationResponse>;
    spellcheck: ({ text, language_code }: SpellCheckParams) => Promise<SpellCheckValidationResponse>;
    spamcheck: (text: string) => Promise<SpamCheckValidationResponse>;
}

declare const JigsawStack: (config?: {
    apiKey?: string;
    baseURL?: string;
}) => {
    fetch: (path: string, method: "POST" | "GET" | "DELETE", body?: Record<string, any> | Blob, searchParams?: {
        [key: string]: any;
    }, headers?: {
        [key: string]: string;
    }) => Promise<any>;
    sentiment: (params: {
        text: string;
    }) => Promise<SentimentResponse>;
    translate: (params: {
        current_language: string;
        target_language: string;
        text: string;
    }) => Promise<TranslateResponse>;
    image_generation: (params: {
        prompt: string;
        model?: "sd1.5" | "sdxl" | "ead1.0" | "rv1.3" | "rv3" | "rv5.1" | "ar1.8";
        size?: "small" | "medium" | "large";
        width?: number;
        height?: number;
        advance_config?: {
            negative_prompt?: string;
            steps?: number;
            guidance?: string;
            seed?: number;
            scheduler?: "dpmsolver++" | "lms" | "ddim" | "euler" | "euler_a" | "pndm";
        };
    }) => Promise<{
        blob: () => Promise<Blob>;
        buffer: () => Promise<Buffer>;
        file: (filename: string) => Promise<globalThis.File>;
    }>;
    summary: (params: {
        text: string;
        type?: "text" | "points";
    }) => Promise<SummaryResponse>;
    prediction: (params: PredictionParams) => Promise<PredictionResponse>;
    text_to_sql: (params: {
        prompt: string;
        sql_schema?: string;
        file_store_key?: string;
    }) => Promise<TextToSQLResponse>;
    audio: Audio;
    geo: Geo;
    vision: Vision;
    web: {
        ai_scrape: (params: AIScrapeParams) => Promise<ScrapeResponse>;
        scrape: (params: ScrapeParams) => Promise<ScrapeResponse>;
        dns: (params: DNSParams) => Promise<DNSResponse>;
        html_to_any: (params: HTMLAnyParams) => Promise<{
            blob: () => Promise<Blob>;
            buffer: () => Promise<Buffer>;
            file: (filename: string) => Promise<globalThis.File>;
        }>;
        search: (params: SearchParams) => Promise<SearchResponse>;
        search_suggestions: (query: string) => Promise<SuggestionResponse>;
    };
    prompt_engine: PromptEngine;
    store: {
        kv: KV;
        upload: (file: Blob | Buffer, params: FileUploadParams) => Promise<FileUploadResponse>;
        retrieve: (key: string) => Promise<{
            blob: () => Promise<Blob>;
            buffer: () => Promise<Buffer>;
            file: (filename: string) => Promise<globalThis.File>;
        }>;
        delete: (key: string) => Promise<BaseResponse>;
    };
    validate: Validate;
};

export { JigsawStack };
