'use strict';

require('isomorphic-fetch');

const respToFileChoice = (resp) => {
  return {
    blob: () => resp.blob(),
    buffer: async () => {
      const arr = await resp.arrayBuffer();
      return Buffer.from(arr);
    },
    file: async (filename) => {
      const arr = await resp.arrayBuffer();
      return new File([Buffer.from(arr)], filename);
    }
  };
};

class Audio {
  constructor(client) {
    this.client = client;
  }
  speech_to_text = async (params) => {
    return await this.client.fetchJSS("/ai/transcribe", "POST", params);
  };
  text_to_speech = async (params) => {
    const resp = await this.client.fetchJSS("/ai/tts", "POST", params);
    return respToFileChoice(resp);
  };
}

class Geo {
  constructor(client) {
    this.client = client;
  }
  search = async (params) => {
    return await this.client.fetchJSS("/geo/search", "GET", {}, params);
  };
  geocode = async (params) => {
    return await this.client.fetchJSS("/geo/geocode", "GET", {}, params);
  };
  city = async (params) => {
    return await this.client.fetchJSS("/geo/city", "GET", {}, params);
  };
  country = async (params) => {
    return await this.client.fetchJSS("/geo/country", "GET", {}, params);
  };
  state = async (params) => {
    return await this.client.fetchJSS("/geo/state", "GET", {}, params);
  };
  distance = async (params) => {
    return await this.client.fetchJSS("/geo/distance", "GET", {}, params);
  };
  timezone = async (params) => {
    return await this.client.fetchJSS("/geo/timezone", "GET", {}, params);
  };
  geohash = async (params) => {
    return await this.client.fetchJSS("/geo/geohash", "GET", {}, params);
  };
  geohash_decode = async (geohash) => {
    return await this.client.fetchJSS(`/geo/geohash/decode/${geohash}`, "GET", {});
  };
}

const baseURL = "https://api.jigsawstack.com/v1";
class RequestClient {
  constructor(config) {
    this.config = config;
  }
  fetchJSS = async (path, method, body, searchParams, headers) => {
    const isFileUpload = body instanceof Blob || body instanceof Buffer;
    const _headers = {
      "x-api-key": this.config?.apiKey,
      "Content-Type": isFileUpload ? "application/octet-stream" : "application/json",
      ...headers
    };
    const _body = isFileUpload ? body : JSON.stringify(body);
    const url = `${this.config?.baseURL || baseURL}${path}`;
    const urlParams = searchParams && Object.keys(searchParams).length ? `?${new URLSearchParams(searchParams).toString()}` : "";
    const resp = await fetch(`${url}${urlParams}`, {
      method,
      headers: _headers,
      body: ["POST", "PATCH"].includes(method) ? _body : void 0
    });
    if (!resp.ok) {
      const error = await resp.json();
      throw error;
    }
    const result = resp.headers.get("Content-Type")?.includes("application/json") ? await resp.json() : resp;
    return result;
  };
}

class Search {
  constructor(client) {
    this.client = client;
  }
  search = async (params) => {
    return await this.client.fetchJSS("/web/search", "GET", void 0, params);
  };
  suggestion = async (query) => {
    return await this.client.fetchJSS(`/web/search/suggest?query=${query}`, "GET", void 0);
  };
}

class Vision {
  constructor(client) {
    this.client = client;
  }
  vocr = async (params) => {
    return await this.client.fetchJSS("/vocr", "POST", params);
  };
  object_detection = async (params) => {
    return await this.client.fetchJSS("/ai/object_detection", "POST", params);
  };
}

class Web {
  constructor(client) {
    this.client = client;
  }
  ai_scrape = async (params) => {
    return await this.client.fetchJSS("/ai/scrape", "POST", params);
  };
  scrape = async (params) => {
    return await this.client.fetchJSS("/web/scrape", "POST", params);
  };
  dns = async (params) => {
    return await this.client.fetchJSS("/web/dns", "GET", {}, params);
  };
  html_to_any = async (params) => {
    const resp = await this.client.fetchJSS("/web/html_to_any", "POST", params);
    return respToFileChoice(resp);
  };
}

class PromptEngine {
  constructor(client) {
    this.client = client;
  }
  create = async (params) => {
    return await this.client.fetchJSS("/prompt_engine", "POST", params);
  };
  run_prompt_direct = async (params) => {
    return await this.client.fetchJSS(`/prompt_engine/run`, "POST", params);
  };
  get = async (id) => {
    return await this.client.fetchJSS(`/prompt_engine/${id}`, "GET", {});
  };
  list = async (params = { limit: 20, page: 0 }) => {
    return await this.client.fetchJSS("/prompt_engine", "GET", {}, params);
  };
  delete = async (id) => {
    return await this.client.fetchJSS(`/prompt_engine/${id}`, "DELETE", {});
  };
  run = async (params) => {
    return await this.client.fetchJSS(`/prompt_engine/${params.id}`, "POST", params);
  };
}

class General {
  constructor(client) {
    this.client = client;
  }
  translate = async (params) => {
    return await this.client.fetchJSS("/ai/translate", "POST", params);
  };
  sentiment = async (params) => {
    return await this.client.fetchJSS("/ai/sentiment", "POST", params);
  };
  image_generation = async (params) => {
    const resp = await this.client.fetchJSS("/ai/image_generation", "POST", params);
    return respToFileChoice(resp);
  };
  text_to_sql = async (params) => {
    return await this.client.fetchJSS("/ai/sql", "POST", params);
  };
  summary = async (params) => {
    return await this.client.fetchJSS("/ai/summary", "POST", params);
  };
  prediction = async (params) => {
    return await this.client.fetchJSS("/ai/prediction", "POST", params);
  };
}

let File$1 = class File {
  constructor(client) {
    this.client = client;
  }
  upload = async (file, params) => {
    return await this.client.fetchJSS(`/store/file`, "POST", file, {
      key: params.filename,
      overwrite: params.overwrite
    });
  };
  retrieve = async (key) => {
    const resp = await this.client.fetchJSS(`/store/file/${key}`, "GET", {});
    return respToFileChoice(resp);
  };
  delete = async (key) => {
    return await this.client.fetchJSS(`/store/file/${key}`, "DELETE", {});
  };
};

class KV {
  constructor(client) {
    this.client = client;
  }
  add = async (params) => {
    return await this.client.fetchJSS(`/store/kv`, "POST", params);
  };
  get = async (key) => {
    return await this.client.fetchJSS(`/store/kv/${key}`, "GET", {});
  };
  delete = async (key) => {
    return await this.client.fetchJSS(`/store/kv/${key}`, "DELETE", {});
  };
}

class Validate {
  constructor(client) {
    this.client = client;
  }
  email = async (email) => {
    return await this.client.fetchJSS(`/validate/email`, "GET", void 0, {
      email
    });
  };
  nsfw = async (url) => {
    return await this.client.fetchJSS(`/validate/nsfw`, "GET", void 0, {
      url
    });
  };
  profanity = async ({ text, censor_replacement = "*" }) => {
    return await this.client.fetchJSS("/validate/profanity", "GET", {}, { text, censor_replacement });
  };
  spellcheck = async ({ text, language_code = "en" }) => {
    return await this.client.fetchJSS("/validate/spell_check", "GET", {}, { text, language_code });
  };
  spamcheck = async (text) => {
    return await this.client.fetchJSS("/ai/spamcheck", "POST", { text });
  };
}

const JigsawStack = (config) => {
  const _apiKey = config?.apiKey || process?.env?.JIGSAWSTACK_API_KEY;
  if (!_apiKey) {
    throw new Error("No JigsawStack API key provided");
  }
  const client = new RequestClient({ apiKey: _apiKey, baseURL: config?.baseURL });
  const general = new General(client);
  const web = new Web(client);
  const search = new Search(client);
  const vision = new Vision(client);
  const audio = new Audio(client);
  const geo = new Geo(client);
  const promptengine = new PromptEngine(client);
  const file = new File$1(client);
  const validate = new Validate(client);
  const store = {
    kv: new KV(client),
    upload: file.upload,
    retrieve: file.retrieve,
    delete: file.delete
  };
  return {
    fetch: client.fetchJSS,
    sentiment: general.sentiment,
    translate: general.translate,
    image_generation: general.image_generation,
    summary: general.summary,
    prediction: general.prediction,
    text_to_sql: general.text_to_sql,
    audio,
    geo,
    vision,
    web: {
      ai_scrape: web.ai_scrape,
      scrape: web.scrape,
      dns: web.dns,
      html_to_any: web.html_to_any,
      search: search.search,
      search_suggestions: search.suggestion
    },
    prompt_engine: promptengine,
    store,
    validate
  };
};

exports.JigsawStack = JigsawStack;
